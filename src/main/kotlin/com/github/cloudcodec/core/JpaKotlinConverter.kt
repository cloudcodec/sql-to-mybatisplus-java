package com.github.cloudcodec.core

import org.mybatis.generator.api.dom.kotlin.*
import org.mybatis.generator.api.dom.kotlin.render.KotlinFileRenderer
import org.mybatis.generator.internal.util.JavaBeansUtil
import java.util.*

object JpaKotlinConverter {

    fun convert(tableInfos: List<TableInfo>, pkg: String): List<OrmThing> {

        return tableInfos.map { tableInfo ->
            generate(tableInfo, pkg)
        }

    }

    private fun generate(tableInfo: TableInfo, pkg: String): OrmThing {
        val entityName = JavaBeansUtil.getCamelCaseString(tableInfo.name.removePrefix("tb_"), true)

        val result = JpaThing(
            MyClass("$pkg.entity", "$entityName"),
            MyClass("$pkg.repository", "${entityName}Repository"),
        )

        result.entity.content = generateEntity(result, tableInfo)
        result.repository.content = generateRepository(result)
        return result
    }

    private fun generateEntity(thing: JpaThing, tableInfo: TableInfo): String {
        val kf = KotlinFile(thing.entity.className)
        kf.setPackage(thing.entity.pkg)

        val clazz = KotlinType.newClass(thing.entity.className)
            .withModifier(KotlinModifier.DATA)
            .build()
        clazz.addAnnotation("@javax.persistence.Entity")
        clazz.addAnnotation("""@javax.persistence.Table(name="${tableInfo.name}")""")
        clazz.addAnnotation("@org.hibernate.annotations.DynamicInsert")
        clazz.addAnnotation("@org.hibernate.annotations.DynamicUpdate")
        kf.addNamedItem(clazz)

        val primaryKeyTypeList =
            tableInfo.columns.filter { it.primaryKey }.map { JavaToKotlinTypeConverter.convert(it.type) }
                .map { it.packageName + "." + it.shortNameWithoutTypeArguments }
        check(primaryKeyTypeList.size == 1) { "one column should be primary key, but exists ${primaryKeyTypeList.size} columns" }
        thing.primaryKeyType = primaryKeyTypeList[0]

        tableInfo.columns.forEach {
            val kotlinType = JavaToKotlinTypeConverter.convert(it.type)
            val columnName = it.name
//            val columnComment = it.comment
            val kp = KotlinProperty.newVar(JavaBeansUtil.getCamelCaseString(columnName, false))
                .withDataType(kotlinType.shortNameWithTypeArguments + "?")
                .withInitializationString("null")
                .build()
            kp.addAnnotation("""@javax.persistence.Column(name="$columnName")""")
            if (it.primaryKey) {
                kp.addAnnotation("@javax.persistence.Id")
            }
            if (it.autoGenerated) {
                kp.addAnnotation("@javax.persistence.GeneratedValue(strategy = javax.persistence.GenerationType.IDENTITY)")
            }
            if (kotlinType.shortNameWithTypeArguments == Date::class.simpleName) {
                if (it.name.lowercase(Locale.getDefault()).contains("create")) {
                    kp.addAnnotation("@org.hibernate.annotations.CreationTimestamp")
                } else if (it.name.lowercase(Locale.getDefault()).contains("update")) {
                    kp.addAnnotation("@org.hibernate.annotations.UpdateTimestamp")
                }
            }
            clazz.addConstructorProperty(kp)
            kf.addImports(kotlinType.importList)
        }

        return KotlinFileRenderer().render(kf)
    }

    private fun generateRepository(thing: JpaThing): String {
        val kf = KotlinFile(thing.repository.className)
        kf.setPackage(thing.repository.pkg)

        val superType =
            FullyQualifiedKotlinType("org.springframework.data.repository.PagingAndSortingRepository<${thing.entity.pkg}.${thing.entity.className},${thing.primaryKeyType}>")
        kf.addImports(superType.importList)
        val clazz = KotlinType.newInterface(thing.repository.className)
            .withSuperType(superType.shortNameWithTypeArguments)
            .build()
        clazz.addAnnotation("@org.springframework.stereotype.Repository")
        kf.addNamedItem(clazz)

        return KotlinFileRenderer().render(kf)
    }

}

